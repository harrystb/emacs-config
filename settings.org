#+TITLE: Emacs settings
#+AUTHOR: Harrison St Baker
#+EMAIL: harry.stbaker@gmail.com
* Package repo configuration
  Add the melpa repository and make sure use-package is installed
#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
  			    ("org" . "https://orgmode.org/elpa/")
  			    ("elpa" . "https://elpa.gnu.org/packages/")))
  (unless package-archive-contents (package-refresh-contents))

  (setq use-package-always-ensure t)
#+END_SRC

* Automatic Package updates
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :custom
    (auto-package-update-interval 7)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe)
    (auto-package-update-at-time "09:00"))
#+END_SRC

* Default Settings, which-key and basic key remaps
** Set custom variable location
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file t)
#+END_SRC
** Remove splash screen, menu bar, scroll-bar, toolbar and echo area on startup
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (when (display-graphic-p)
    (scroll-bar-mode -1))
#+END_SRC
** Setup line numbers
#+BEGIN_SRC emacs-lisp
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode t)
#+END_SRC
** Setup font
#+BEGIN_SRC emacs-lisp
  (when (and (window-system) (x-list-fonts "JetBrainsMono NF"))
    (set-frame-font "JetBrainsMono NF"))
#+END_SRC
** Enable which-key on pause
#+BEGIN_SRC emacs-lisp
  (which-key-mode 1)
  (setq which-key-side-window-location '(right, bottom))
#+END_SRC
* UI Changes
** Utility for installing system fonts
Run the command "all-the-icons-install-fonts" to install the fonts to the system
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons :if (display-graphic-p))
#+END_SRC
** Colour theme Doom (dark)
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :ensure t
    :custom
    ;; Global settings (defaults)
    (doom-themes-enable-bold t)   ; if nil, bold is universally disabled
    (doom-themes-enable-italic t) ; if nil, italics is universally disabled
    :config
    (load-theme 'doom-dracula t)
    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    ;; Enable custom neotree theme (nerd-icons must be installed!)
    (doom-themes-neotree-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+END_SRC
** Mode line
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1))
#+END_SRC
* Org mode customisations
#+BEGIN_SRC emacs-lisp
  (defun hb-org-mode-setup ()
    (org-indent-mode)
    (visual-line-mode 1))
  (use-package org
    :pin org
    :commands (org-capture org-agenda)
    :hook (org-mode . hb-org-mode-setup)
    :config
    (setq org-ellipsis " â–¾")
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    (setq org-cycle-emulate-tab 'white)
    (setq org-agenda-files (list "~/org/" user-emacs-directory "~/dev/blink/")))
  (use-package evil-org
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))
#+END_SRC
* Key bindings
** Enable kitty protocol (pass through super on terminal)
#+BEGIN_SRC emacs-lisp
(unless (display-graphic-p) (use-package kkp
  :config
  (global-kkp-mode 1)))
#+END_SRC
** Basic changes
Setup escape to exit all popups and panels
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC
** Evaluate commands
#+BEGIN_SRC emacs-lisp
  (setq hb-eval-map (make-sparse-keymap))
  (define-key hb-eval-map "r" '("Evaluate region" . eval-region))
  (define-key hb-eval-map "s" '("Evaluate Last Symbolic Expression" . eval-last-sexp))
  (define-key hb-eval-map "x" '("Execute Command" . execute-extended-command))
  (setq help-char "")
#+END_SRC
** File commands
#+BEGIN_SRC emacs-lisp
  (setq hb-file-map (make-sparse-keymap))
  (define-key hb-file-map "f" '("Find file" . helm-find-files))
  (define-key hb-file-map "d" '("Open dired in folder of this file" . dired))
  (define-key hb-file-map "c" '("Open emacs config file" . (lambda () (interactive) (find-file (concat user-emacs-directory "settings.org")))))
#+END_SRC
** Buffer commands
#+BEGIN_SRC emacs-lisp
  (setq hb-other-buffer-map (make-sparse-keymap))
  (define-key hb-other-buffer-map "w" '("Switch Buffer Other Window" . consult-buffer-other-window))
  (define-key hb-other-buffer-map "f" '("Switch Buffer Other Frame" . consult-buffer-other-frame))
  (define-key hb-other-buffer-map "t" '("Switch Buffer Other Tab" . consult-buffer-other-tab))
  (setq hb-buffer-map (make-sparse-keymap))
  (define-key hb-buffer-map "b" '("Switch to buffer" . consult-buffer))
  (define-key hb-buffer-map "p" '("Switch to project buffer" . consult-project-buffer))
  (define-key hb-buffer-map "o" (cons "Switch to buffer in other..." hb-other-buffer-map))
  (define-key hb-buffer-map "l" '("List buffers" . list-buffers))
#+END_SRC
** Org commands
#+BEGIN_SRC emacs-lisp
  (setq hb-org-map (make-sparse-keymap))
  (define-key hb-org-map "p" '("Format paragraph" . org-fill-paragraph))
  (define-key hb-org-map "a" '("Agenda" . org-agenda))
  (define-key hb-org-map "t" '("Insert Timestamp" . org-timestamp))
#+END_SRC
** Custom Harpoon functionality
#+BEGIN_SRC emacs-lisp
  (defvar hb-harpoon-list () "The list of buffers in the harpoon quick list")
  (defun hb-harpoon-add ()
    "Add this file to the harpoon list"
    (interactive)
    (let ((filename ""))
      (setq filename buffer-file-name)
      (if filename
  	(progn 
  	  (if hb-harpoon-list
  	      (unless (member filename hb-harpoon-list)
  		(setq hb-harpoon-list (append hb-harpoon-list (list filename)))
  		(message "File added")
  		)
  	    (setq hb-harpoon-list (list filename))
  	    (message "File added")
  	    )
  	  (hb-harpoon-save-to-disk))
        (message "Buffer is not a file")
        )))
  (defun hb-harpoon-remove ()
    "Add this file to the harpoon list"
    (interactive)
    (let ((filename ""))
      (setq filename buffer-file-name)
      (when (member filename hb-harpoon-list)
        (setq hb-harpoon-list (delete filename hb-harpoon-list))
        (message "File removed"))
      ))
  (defun hb-harpoon-clear ()
    (interactive)
    (setq hb-harpoon-list ()))
  (defun hb-harpoon-switch (n)
    "Quick switch to harpoon buffer n"
    (let (
          (file (nth n hb-harpoon-list)))
      (if file (find-file file) (message "Harpoon item %d not set" n))
      ))
  (defun hb-harpoon-list ()
    "Show *Harpoon Buffers* buffer"
    (interactive)
    ;; Create or update harpoon buffer
    (let ((buf (get-buffer-create "*Harpoon*")))
      (switch-to-buffer buf)
      (hb-harpoon-list-mode 1)
      (insert ";; Harpoon Quick Switch List:\n")
      (insert ";; Edit the buffer to rearrange the order if desired.\n")
      (insert ";; <q> save and quit    <enter> switch to buffer\n")
      (insert ";;  __________________________________________________\n\n")
      (save-excursion 
  	(dolist (file hb-harpoon-list)
  	  (insert (concat file "\n"))))))

  (defun hb-harpoon-load-from-buffer()
    (save-excursion
      (goto-char (point-min))
      (setq hb-harpoon-list ())
      (while (not (eobp))
        (let ((filename (string-trim (thing-at-point 'line t))))
  	(unless (or (not filename) (< (length filename) 2) (equal (substring filename 0 2) ";;"))
  	  (if hb-harpoon-list
  	      (unless (member filename hb-harpoon-list)
  		(setq hb-harpoon-list (append hb-harpoon-list (list filename)))
  		)
  	    (setq hb-harpoon-list (list filename))
  	    )))
        (forward-line 1)
        )
      ))
  (defvar hb-harpoon-data-file (concat user-emacs-directory "harpoon") "File that harpoon syncs with")
  (defun hb-harpoon-load-from-disk()
    (interactive)
    (let ((buf (find-file-noselect hb-harpoon-data-file)))
      (with-current-buffer buf
        (hb-harpoon-load-from-buffer))
      (kill-buffer buf)))
  (defun hb-harpoon-save-to-disk()
    (with-temp-buffer 
      (dolist (file hb-harpoon-list)
        (insert (concat file "\n")) 
        )
      (write-region (point-min) (point-max) hb-harpoon-data-file nil 0)))
  (defun hb-harpoon-list-kill ()
    (interactive)
    (let ((buf (get-buffer-create "*Harpoon*")))
      (with-current-buffer buf
      (hb-harpoon-load-from-buffer)
      (hb-harpoon-save-to-disk))
      (kill-buffer buf)))
  (defun hb-harpoon-list-switch ()
    (interactive)
    (let ((line (string-trim (thing-at-point 'line t))))
      (unless (or (< (length line) 2) (equal (substring line 0 2) ";;"))
        (find-file line)
        (hb-harpoon-list-kill)
        )
      ))
  (hb-harpoon-load-from-disk)
  ;; Setup minor mode
  (defvar hb-harpoon-list-map (make-sparse-keymap) "Keymap for harpoon list mode")
  (define-key hb-harpoon-list-map "q" '("Save and close Harpoon list buffer" . hb-harpoon-list-kill))
  (keymap-set hb-harpoon-list-map "<remap> <evil-record-macro>" 'hb-harpoon-list-kill)
  (define-key hb-harpoon-list-map "<return>" '("Switch to buffer" . hb-harpoon-list-switch))
  (keymap-set hb-harpoon-list-map "<remap> <evil-ret>" 'hb-harpoon-list-switch)
  (define-minor-mode hb-harpoon-list-mode
    "Toggles the harpoon list mode."
    :init-value nil
    :global nil
    :lighter " harpoon"
    :keymap hb-harpoon-list-map
    (if hb-harpoon-list-mode
        (message "Harpoon on")
      (message "Harpoon off")))

  (setq hb-harpoon-map (make-sparse-keymap))
  (define-key hb-harpoon-map "a" '("Add file to harpoon" . hb-harpoon-add))
  (define-key hb-harpoon-map "d" '("Remove file from harpoon" . hb-harpoon-remove))
  (define-key hb-harpoon-map "c" '("Clear harpoon files" . hb-harpoon-clear))
  (define-key hb-harpoon-map "m" '("List harpoon files" . hb-harpoon-list))
  (define-key global-map (kbd "C-h") '("Quickswitch to buffer 1" . (lambda () (interactive) (hb-harpoon-switch 0))))
  (define-key global-map (kbd "C-j") '("Quickswitch to buffer 2" . (lambda () (interactive) (hb-harpoon-switch 1))))
  (define-key global-map (kbd "C-k") '("Quickswitch to buffer 3" . (lambda () (interactive) (hb-harpoon-switch 2))))
  (define-key global-map (kbd "C-l") '("Quickswitch to buffer 4" . (lambda () (interactive) (hb-harpoon-switch 3))))
#+END_SRC
*** Unbind competing keybinds from other modes
#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "C-j") nil)
#+END_SRC
** Blink helpful bindings
*** Compile commands
#+BEGIN_SRC emacs-lisp
  (setq hb-blink-watch-map (make-sparse-keymap))
  (define-key hb-blink-watch-map "c" '("Watch custom" . (lambda (&optional cmd) (interactive "sBin Name:") (compile (format "cd %s && cargo watch -x \"run --bin %s\"" (projectile-project-root) cmd)))))
  (define-key hb-blink-watch-map "t" '("Watch tmpltst" . (lambda () (interactive) (compile (format "cd %s && cargo watch -x \"run --bin tmpltst\"" (projectile-project-root))))))
  (setq hb-blink-map (make-sparse-keymap))
  (define-key hb-blink-map "c" '("Run custom" . (lambda (&optional cmd) (interactive "sBin name:") (compile (format "cd %s && cargo run --bin %s" (projectile-project-root) cmd)))))
  (define-key hb-blink-map "t" '("Run tmpltst" . (lambda () (interactive) (compile (format "cd %s && cargo run --bin tmpltst" (projectile-project-root))))))
  (define-key hb-blink-map "w" (cons "Watch commands" hb-blink-watch-map))
#+END_SRC
** Evil package (VIM Emulation)
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config
    (evil-mode 1)
    (evil-set-undo-system 'undo-redo)
    (evil-set-leader '(normal visual motion) (kbd "SPC"))
    (evil-define-key '(normal visual motion) 'global (kbd "<leader>h") (cons "Help Commands" help-map))
    (evil-define-key '(normal visual motion) 'global (kbd "<leader>p") '("Projectile commands" . projectile-command-map))
    (evil-define-key '(normal visual motion) 'global (kbd "<leader>b") (cons "Buffer commands" hb-buffer-map))
    (evil-define-key '(normal visual motion) 'global (kbd "<leader>f") (cons "File commands" hb-file-map))
    (evil-define-key '(normal visual motion) 'global (kbd "<leader>e") (cons "Evaluate commands" hb-eval-map))
    (evil-define-key '(normal visual motion) 'global (kbd "<leader>m") (cons "Harpoon commands" hb-harpoon-map))
    (evil-define-key '(normal visual motion) 'global (kbd "<leader>o") (cons "Org commands" hb-org-map))
    (evil-define-key '(normal visual motion) 'global (kbd "<leader>c") (cons "Blink commands" hb-blink-map))
    (evil-define-key 'visual 'global (kbd "(") (lambda () (interactive) (insert-pair ?\( ?\)))
      (kbd "{") (lambda () (interactive) (insert-pair ?\{ ?\}))
      (kbd "[") (lambda () (interactive) (insert-pair ?\[ ?\]))
      (kbd "<") (lambda () (interactive) (insert-pair ?\< ?\>))
      (kbd "\"") (lambda () (interactive) (insert-pair ?\" ?\")))
    (evil-define-key 'normal org-mode-map (kbd "TAB") #'org-cycle)
    (use-package evil-org
      :ensure t
      :after org
      :hook (org-mode . (lambda () evil-org-mode))
      :config
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys)
      ))
#+END_SRC
* Completion System
** Completion UI
[[https://github.com/minad/vertico][Vertico]]
#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :init
    (vertico-mode))
  (use-package emacs
    :custom
    (context-menu-mode t)
    (enable-recursive-minibuffers t)
    (read-extended-command-predicate #'command-completion-default-include-p)
    (minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt)))
#+END_SRC
** Addition information in margins
[[https://github.com/minad/marginalia][Marginalia]]
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :bind (:map minibuffer-local-map ("M-A" . marginalia-cycle))
    :init
    (marginalia-mode))
#+END_SRC
** Enhanced completion pattern 
[[https://github.com/oantolin/orderless][Orderless]]
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles partial-completion))))
    (completion-pcm-leading-wildcard t))
#+END_SRC
** Enhanced Search & Navigation
[[https://github.com/minad/consult][Consult]]
#+BEGIN_SRC emacs-lisp
;; Example configuration for Consult
(use-package consult
  ;; Replace bindings. Lazily loaded by `use-package'.
  :bind (;; C-c bindings in `mode-specific-map'
         ("C-c M-x" . consult-mode-command)
         ("C-c h" . consult-history)
         ("C-c k" . consult-kmacro)
         ("C-c m" . consult-man)
         ("C-c i" . consult-info)
         ([remap Info-search] . consult-info)
         ;; C-x bindings in `ctl-x-map'
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings in `goto-map'
         ("M-g e" . consult-compile-error)
         ("M-g r" . consult-grep-match)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings in `search-map'
         ("M-s d" . consult-find)                  ;; Alternative: consult-fd
         ("M-s c" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Tweak the register preview for `consult-register-load',
  ;; `consult-register-store' and the built-in commands.  This improves the
  ;; register formatting, adds thin separator lines, register sorting and hides
  ;; the window mode line.
  (advice-add #'register-preview :override #'consult-register-window)
  (setq register-preview-delay 0.5)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key "M-.")
  ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep consult-man
   consult-bookmark consult-recent-file consult-xref
   consult-source-bookmark consult-source-file-register
   consult-source-recent-file consult-source-project-recent-file
   ;; :preview-key "M-."
   :preview-key '(:debounce 0.4 any))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; "C-+"

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
)
#+END_SRC
** Enhanced actions at point
[[https://github.com/oantolin/embark][Embark]]
#+BEGIN_SRC emacs-lisp
(use-package embark
  :ensure t

  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-x B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)
  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+END_SRC
* Navigation
** Project navigation
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode +1)
    (setq projectile-project-search-path '("~/dev"))
    (projectile-register-project-type 'gitea '(".gitea")
                      :compile "RHOST=hts-nms1 gmake install")
    :bind
    (("<leader> p" . 'projectile-command-map)))
#+END_SRC
** #DISABLED Treemacs package (folder display and navigation)
If re-enabling, check out an alternative is Neotree.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package treemacs
    :ensure t
    :config
    (use-package treemacs-evil
      :ensure t)
    (use-package treemacs-magit
      :ensure t)
    (use-package treemacs-projectile
      :ensure t)
    :bind
    (:map global-map
	  ("M-0" . treemacs-select-window)
	  ("C-x t 1"   . treemacs-delete-other-windows)
	  ("C-x t t"   . treemacs)
	  ("C-x t B"   . treemacs-bookmark)
	  ("C-x t C-t" . treemacs-find-file)
	  ("C-x t M-t" . treemacs-find-tag)))
#+END_SRC

* Programming
** Treesitter (precompiled)
Pre-compiled tree-sitter languages can be downloaded using the
"tree-sitter-langs-install-grammars" function. They get stored
somewhere along the lines of
"/.emacs.d/elpa/tree-sitter-langs-20251102.1741/bin/".

The files that are wanted can be copied from that location and placed
in the "/.emacs.d/tree-sitter" folder with the name prefixed with
"libtree-sitter-"
#+BEGIN_SRC emacs-lisp
  (use-package tree-sitter-langs :ensure t)
  #+END_SRC
** #DISABLED Treesitter (manual install)
Allows the function "treesit-install-language-grammar" to be used to
install and compile one of these languages. Requires a c compiler (cc
or gcc) and c++ compiler (g++).
#+BEGIN_SRC emacs-lisp :tangle no
  (setq treesit-language-source-alist '(
  (rust . ("https://github.com/tree-sitter/tree-sitter-rust" "v0.23.2")) ;v0.23.2 until emacs treesitter support ABI version (https://github.com/rust-lang/rust-mode/issues/568) 
  (python . ("https://github.com/tree-sitter/tree-sitter-python"))
  (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript"))
  (c . ("https://github.com/tree-sitter/tree-sitter-c"))
  (cpp . ("https://github.com/tree-sitter/tree-sitter-cpp"))
  (json . ("https://github.com/tree-sitter/tree-sitter-json"))
  (html . ("https://github.com/tree-sitter/tree-sitter-html"))
  (css . ("https://github.com/tree-sitter/tree-sitter-css"))))
  #+END_SRC
** #DISABLED LSP (lsp-mode)
#+BEGIN_SRC emacs-lisp :tangle no
    (use-package lsp-mode
      :ensure t
      :hook
      (dart-mode . lsp-mode)
      (rust-mode . lsp-mode)
      (rustic-mode . lsp-mode)
      :config
      (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]ios(\/|\\\\)(build|Pods|Runner|Share Extension)\\")
      (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]ios(\/|\\\\)build\\")
      )
#+END_SRC
** LSP (Built in eglot)
#+BEGIN_SRC emacs-lisp
      (use-package eglot
        :demand t
        :hook
        (dart-mode . eglot-ensure)
        (rust-mode . eglot-ensure)
        (rust-ts-mode . eglot-ensure)
        (rustic-mode . eglot-ensure)
        :bind
        (:map eglot-mode-map
    	  ("C-c a" . eglot-code-actions)
    	  ("C-c r" . eglot-rename)
    	  ("C-c d" . eldoc)
  	  )
        )
#+END_SRC
** Annotations
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC
** #DISABLED Rust (rustic-mode)
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package rustic
    :ensure t
    :after rust-mode
    :config
    (setq rustic-format-on-save t)
    )
#+END_SRC
** Rust (rust-mode/rust-ts-mode)
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :init
    (setq rust-mode-treesitter-derive t)
    :config
    (add-hook 'rust-mode-hook (lambda () (setq indent-tabs-mode nil)))
    (add-hook 'rust-mode-hook 'electric-pair-mode)
    (add-hook 'rust-mode-hook 'flycheck-mode)
    (add-hook 'rust-mode-hook 'company-mode)
    )
#+END_SRC
** Flutter/Dart Packages
#+BEGIN_SRC emacs-lisp
  (use-package dart-mode
    :ensure t
    :hook
    (dart-mode . flutter-test-mode)
    (dart-mode . electric-pair-mode))
  (use-package flutter
    :ensure t
    :after dart-mode
    :config 
    (defun my-flutter-run-or-hot-reload ()
      "Start `flutter run` or hot-reload if already running."
      (interactive)
      (if (flutter--running-p)
  	(flutter-hot-reload)
        (flutter-run "-d windows")))
    (defun my-flutter-before-save ()
      (lsp-format-buffer))
    (defun my-flutter-on-save-hot-reload ()
      "Start `flutter run` or hot-reload if already running."
      (lsp-format-buffer)
      (if (flutter--running-p)
  	(flutter-hot-reload)
        nil))
    (add-hook 'flutter-test-mode-hook (lambda () (add-hook 'after-save-hook 'my-flutter-on-save-hot-reload nil 'make-it-local)))
    (add-hook 'flutter-test-mode-hook (lambda () (add-hook 'before-save-hook 'my-flutter-before-save nil 'make-it-local)))
    :bind (:map hb-blink-map
  	      ("f" . #'my-flutter-run-or-hot-reload)))
  (use-package yaml-mode :ensure t)
#+END_SRC
** Web dev (templating languages)
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode
    (("\\.html" . web-mode))
    :config
    (setq web-mode-engines-alist '(("django" . "\\.html"))))
#+END_SRC

* Auto completion and snippets (Company/Yasnippet)
** Smarter completion functions
[[https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/#:~:text=%20Configuring%20Emacs%20for%20Rust%20development%20%201,order%20to%20setup%20debugging%20support%20for...%20More%20][Source of these functions]]
#+BEGIN_SRC emacs-lisp
(defun company-yasnippet-or-completion ()
  (interactive)
  (or (do-yas-expand)
      (company-complete-common)))

(defun check-expansion ()
  (save-excursion
    (if (looking-at "\\_>") t
      (backward-char 1)
      (if (looking-at "\\.") t
        (backward-char 1)
        (if (looking-at "::") t nil)))))

(defun do-yas-expand ()
  (let ((yas/fallback-behavior 'return-nil))
    (yas/expand)))

(defun tab-indent-or-complete ()
  (interactive)
  (if (minibufferp)
      (minibuffer-complete)
    (if (or (not yas/minor-mode)
            (null (do-yas-expand)))
        (if (check-expansion)
            (company-complete-common)
          (indent-for-tab-command)))))
#+END_SRC
** Company (Completions)
#+BEGIN_SRC emacs-lisp
(use-package company
    :custom
	(company-idle-delay 0.5) ;; how long to wait until popup
	;; (company-begin-commands nil) ;; uncomment to disable popup
    :bind
	(:map company-active-map
		("C-n". company-select-next)
		("C-p". company-select-previous)
		("M-<". company-select-first)
		("M->". company-select-last))
	(:map company-mode-map
		("<tab>". tab-indent-or-complete)
		("TAB". tab-indent-or-complete))
    :config
    (add-hook 'rust-mode-hook 'company-mode)
    (add-hook 'rustic-mode-hook 'company-mode))
#+END_SRC
** Yasnippet (Snippets)
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (use-package yasnippet-snippets
    :ensure t)
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "C-'") #'yas-expand)
  (add-to-list #'yas-snippet-dirs "~/.emacs.d/snippets")
  (yas-reload-all)
  (add-hook 'prog-mode-hook 'yas-minor-mode)
  (add-hook 'text-mode-hook 'yas-minor-mode)
  (setq yas-prompt-functions '(yas-ido-prompt))
  (defun help/yas-after-exit-snippet-hook-fn ()
    (prettify-symbols-mode)
    (prettify-symbols-mode))
  (add-hook 'yas-after-exit-snippet-hook #'help/yas-after-exit-snippet-hook-fn)
  :diminish yas-minor-mode)
(add-hook 'find-file-hook 'auto-insert)
(use-package yatemplate
  :ensure t
  :config
  (setq templates-private-directory "~/.emacs.d/templates"))
#+END_SRC

** Extra functionality
*** ISpell package (spell checking)
#+BEGIN_SRC emacs-lisp
(use-package ispell
  :ensure t
  :bind
  (("<leader>sw" . 'ispell-word)
   ("<leader>sr" . 'ispell-region)))
#+END_SRC
*** Magit (git in emacs)
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind
    (("<leader> g" . 'magit))
  )
#+END_SRC
*** Mermaid JS Documentation extras (org mode)
#+BEGIN_SRC emacs-lisp
(use-package mermaid-mode
  :ensure t)
#+END_SRC
** Custom Functions
*** Increment or Decrement number at point
#+BEGIN_SRC emacs-lisp
(defun my-increment-number-decimal (&optional arg)
  "Increment the number forward from point by 'arg'."
  (interactive "p*")
  (save-excursion
    (save-match-data
      (let (inc-by field-width answer)
        (setq inc-by (if arg arg 1))
        (skip-chars-backward "0123456789")
        (when (re-search-forward "[0-9]+" nil t)
          (setq field-width (- (match-end 0) (match-beginning 0)))
          (setq answer (+ (string-to-number (match-string 0) 10) inc-by))
          (when (< answer 0)
            (setq answer (+ (expt 10 field-width) answer)))
          (replace-match (format (concat "%0" (int-to-string field-width) "d")
                                 answer)))))))
(defun my-decrement-number-decimal (&optional arg)
  (interactive "p*")
  (my-increment-number-decimal (if arg (- arg) -1)))
(global-set-key (kbd "C-<kp-add>") 'my-increment-number-decimal)
(global-set-key (kbd "C-<kp-subtract>") 'my-decrement-number-decimal)
(define-key function-key-map (kbd "<f13>") 'event-apply-super-modifier)
#+END_SRC

